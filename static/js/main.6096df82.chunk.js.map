{"version":3,"sources":["services/ipfs.js","components/App/App.jsx","../node_modules/web3-eth-accounts/src sync","serviceWorker.js","index.js","constants/contractDefinitions.js","services/contract.js"],"names":["ipfs","IPFS","host","port","protocol","App","props","state","ipfsHash","buffer","ethAddress","formAddress","formIPFS","imgUrl","statusMsg","captureFile","bind","convertToBuffer","handleSubmitIPFS","handleSubmitSC","setEventListeners","handleChangeIPFS","handleChangeAddress","console","log","contract","signer","getAddress","userAddress","this","setState","error","message","alert","on","address","event","toUpperCase","evt","target","value","stopPropagation","preventDefault","file","files","reader","window","FileReader","readAsArrayBuffer","onloadend","Buffer","from","result","sendIPFS","tx","wait","receipt","status","add","err","hash","image","length","alt","src","lg","md","id","className","onSubmit","type","name","onChange","for","size","Component","webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","contractDefinitions","abi","web3","Web3","currentProvider","provider","ethers","providers","Web3Provider","Contract","connect","getSigner"],"mappings":"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","file":"static/js/main.6096df82.chunk.js","sourcesContent":["//imports the IPFS API\nimport IPFS from 'ipfs-http-client';\n\n/**\n * creates & exports new instance for \n * IPFS using infura as host, for use.\n */\nconst ipfs = new IPFS({ host: 'ipfs.infura.io', port: 5001, protocol: 'https' });\n\nexport default ipfs;","import React, { Component } from 'react';\nimport { Container, Row, Col } from 'react-bootstrap';\nimport './App.css';\nimport contract from '../../services/contract';\nimport ipfs from '../../services/ipfs';\n\n//Tutorials: https://itnext.io/build-a-simple-ethereum-interplanetary-file-system-ipfs-react-js-dapp-23ff4914ce4e\n// https://medium.com/@alexma6614/ethereum-ipfs-react-dapp-tutorial-pt-3-dc091408db64\nexport default class App extends Component {\n\n  constructor(props) {\n    super(props)\n    this.state = {\n      ipfsHash: null,\n      buffer: '',\n      ethAddress: '',\n      formAddress: '0x8e287B1F206eF762D460598bdE1A9C22db6b6382',\n      formIPFS: '',\n      imgUrl: '',\n      statusMsg: 'Waiting for submission',\n    }\n    this.captureFile = this.captureFile.bind(this);\n    this.convertToBuffer = this.convertToBuffer.bind(this);\n    this.handleSubmitIPFS = this.handleSubmitIPFS.bind(this);\n    this.handleSubmitSC = this.handleSubmitSC.bind(this);\n    this.setEventListeners = this.setEventListeners.bind(this);\n    this.handleChangeIPFS = this.handleChangeIPFS.bind(this);\n    this.handleChangeAddress = this.handleChangeAddress.bind(this);\n    console.log('contract', contract);\n    console.log('ipfs', ipfs);\n  }\n\n  async componentDidMount() {\n    //console.log('componentDidMount/contract.signer', contract.signer.provider._web3Provider)\n    try {\n      const userAddress = await contract.signer.getAddress()\n      console.log('componentDidMount/userAddress', userAddress)\n      this.setState({\n        ethAddress: userAddress,\n      })\n    } catch (err) {\n      console.error('componentDidMount/error', err.message)\n      alert('An error occurred. Could you confirm if your Metamask is open and running?')\n    }\n    this.setEventListeners()\n  }\n\n  setEventListeners() {\n    contract.on('ipfsSent', (ipfsHash, address, event) => {\n      console.log('setEventListeners/ipfsSent/event', event)\n      if (address.toUpperCase() === this.state.ethAddress.toUpperCase()) {\n        this.setState({\n          ipfsHash: ipfsHash,\n          imgUrl: `https://gateway.ipfs.io/ipfs/${ipfsHash}`,\n          statusMsg: `Your received a file https://gateway.ipfs.io/ipfs/${ipfsHash}`,          \n        })\n      }\n    })    \n  }\n\n  handleChangeAddress(evt) {\n    this.setState({\n      formAddress: evt.target.value,\n    })\n  }\n\n  handleChangeIPFS(evt) {\n    this.setState({\n      formIPFS: evt.target.value,\n    })\n  }\n\n  captureFile(event) {\n    event.stopPropagation()\n    event.preventDefault()\n    const file = event.target.files[0]\n    let reader = new window.FileReader()\n    reader.readAsArrayBuffer(file)\n    reader.onloadend = () => this.convertToBuffer(reader)    \n  }\n\n  async convertToBuffer(reader) {\n    const buffer = await Buffer.from(reader.result)\n    this.setState({\n      buffer: buffer,\n    })\n  }  \n\n  async handleSubmitSC(event) {\n    event.preventDefault()\n    this.setState({\n      statusMsg: 'Submiting IPFS Hash to the Smart Contract'\n    })\n    try {\n      let tx = await contract.sendIPFS(this.state.formAddress, this.state.formIPFS)\n      let receipt = await tx.wait(1);\n      if (receipt.status === 1) {\n        console.log('handleSubmitSC/sucesso/tx', tx, receipt)\n        this.setState({\n          statusMsg: 'IPFS file registered to ' + this.state.formAddress\n        })\n      } else {\n        this.setState({\n          statusMsg: 'Error when executing sendIPFS contract method'\n        })\n      }\n    } catch (err) {\n      console.error('handleSubmitSC ', err)\n      this.setState({\n        statusMsg: 'Error when executing sendIPFS contract method ' + err.message\n      })\n    }\n  }\n\n  async handleSubmitIPFS(event) {\n    event.preventDefault()\n    this.setState({\n      statusMsg: 'Submiting file to IPFS network',\n    })\n    await ipfs.add(this.state.buffer, (err, ipfsHash) => {\n      if (err) {\n        console.error(err.message)\n        this.setState({\n          buffer: '',\n          statusMsg: err.message,\n        })\n        return\n      }\n      console.log('handleClick/sucesso/ipfsHash', ipfsHash)\n      this.setState({\n        formIPFS: ipfsHash[0].hash,\n        statusMsg: 'The IPFS hash is https://gateway.ipfs.io/ipfs/' + ipfsHash[0].hash\n      })      \n    })\n  }\n\n  render() {\n    let image = ''\n    if (this.state.imgUrl.length>10) {\n     image = <img alt={this.state.imgUrl} src={this.state.imgUrl} />\n    }\n    return (\n      <Container>\n        <Row>\n          <Col lg=\"2\">\n            &nbsp;\n          </Col>\n          <Col lg=\"6\" md=\"auto\">\n            <Container>\n              <Row>\n                <Col>\n                  <h2>\n                    1. Add a file to IPFS here\n                  </h2>\n                  <form id=\"frmFile\" className=\"scep-form\" onSubmit={this.handleSubmitIPFS}>\n                    <input type=\"file\" name=\"fileToSend\" id=\"fileToSend\" onChange={this.captureFile} />\n                    <br />\n                    <button type=\"submit\">Send it</button>\n                  </form>\n                </Col>\n              </Row>\n              <Row>\n                <Col>\n                  <h2>\n                    2. Send notifications here\n                  </h2>\n                  <form id=\"frmNotifications\" className=\"scep-form\" onSubmit={this.handleSubmitSC}>\n                    <div>\n                      <div>\n                        <label for=\"receiverAddress\">\n                          Receiver address:\n                        </label>\n                        <input size=\"50\" type=\"text\" name=\"receiverAddress\" id=\"receiverAddress\" value={this.state.formAddress} onChange={this.handleChangeAddress} />\n                      </div>\n                      <div>\n                        <label for=\"ipfsHash\">\n                          IPFS hash:\n                        </label>\n                        <input size=\"128\" type=\"text\" name=\"ipfsHash\" id=\"ipfsHash\" value={this.state.formIPFS} onChange={this.handleChangeIPFS} />\n                      </div>\n                    </div>\n                    <br />\n                    <div>\n                      <button type=\"submit\">Register it</button>\n                    </div>\n                  </form>\n                </Col>\n              </Row>              \n            </Container>\n          </Col>\n          <Col lg=\"4\">\n            <br />\n            <hr/>\n            <br/>\n            <div>\n              <p>\n                Status: {this.state.statusMsg}\n                <br />\n                { image }\n              </p>\n            </div>\n          </Col>\n        </Row>\n      </Container>\n    );\n  }\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 543;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App/App'\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","const contractDefinitions = {\n  address: '0x0be1fac9f474c185c7138f983ac55d9c41635351',\n  abi: [\n    {\n      \"constant\": false,\n      \"inputs\": [],\n      \"name\": \"checkInbox\",\n      \"outputs\": [],\n      \"payable\": false,\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": false,\n          \"name\": \"_ipfsHash\",\n          \"type\": \"string\"\n        },\n        {\n          \"indexed\": false,\n          \"name\": \"_address\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"ipfsSent\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": false,\n          \"name\": \"response\",\n          \"type\": \"string\"\n        }\n      ],\n      \"name\": \"inboxResponse\",\n      \"type\": \"event\"\n    },\n    {\n      \"constant\": false,\n      \"inputs\": [\n        {\n          \"name\": \"_address\",\n          \"type\": \"address\"\n        },\n        {\n          \"name\": \"_ipfsHash\",\n          \"type\": \"string\"\n        }\n      ],\n      \"name\": \"sendIPFS\",\n      \"outputs\": [],\n      \"payable\": false,\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"payable\": false,\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"constructor\"\n    }\n  ]\n};\n\nexport default contractDefinitions;","import { ethers } from 'ethers';\nimport Web3 from 'web3';\n\nimport contractDefinitions from '../constants/contractDefinitions';\n\nlet contract = null;\n\nif (window.web3) {\n  const web3 = new Web3(window.web3.currentProvider);\n  try {\n      // Solicita acesso a carteira Ethereum se necessário\n      const provider = new ethers.providers.Web3Provider(web3.currentProvider);\n      const tmpContract = new ethers.Contract(contractDefinitions.address, contractDefinitions.abi, provider);\n      contract = tmpContract.connect(provider.getSigner());\n  } catch (err) { // Usuário ainda não deu permissão para acessar a carteira Ethereum    \n      console.log(\"error connecting to Ethereum via Metamask or other wallet\"); \n      console.error(err);           \n  }\n}\n\nexport default contract;"],"sourceRoot":""}